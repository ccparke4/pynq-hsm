`timescale 1ns/1ps

// ================================================================
// Golden vectors loaded from hex files generated by 
// scripts/gen_aes_kat.py (python AES-256 from GF math)
//    stage 2a: key schedule -> check W[8]...W[11] against NIST
//    stage 2b: full KAT -> encrypt N vectors and compare ciphertext
//  Run from root
//     make vectors  -> gen golden files
//     make sim-core  -> compile, elaborate, simulate
// Pass criteria: all vectors match golden, $fatal not triggered.
// ================================================================

module tb_aes_core;

    // params =================================
    localparam CLK_PERIOD = 10;
    localparam NUM_VECTORS = 3;
    localparam TIMEOUT_CYCLES = 200;

    // DUT signals =============================
    logic           clk;
    logic           rst_n;
    logic [255:0]   key;
    logic           key_valid;
    logic [127:0]   plaintext;
    logic           encrypt_start;
    logic           clear;
    logic           ready;
    logic           busy;
    logic           done;
    logic [127:0]   ciphertext;

    // DUT inst. =================================
    aes_core dut (
        .clk           (clk),
        .rst_n         (rst_n),
        .key           (key),
        .key_valid     (key_valid),
        .plaintext     (plaintext),
        .encrypt_start (encrypt_start),
        .clear         (clear),
        .ready         (ready),
        .busy          (busy),
        .done          (done),
        .ciphertext    (ciphertext)
    );

    // CLK Gen ========================================
    initial clk = 0;
    always #(CLK_PERIOD / 2) clk = ~clk;

    // Golden vecs - loaded from hex files ============
    // Kat file: 4 lines/vec (key_hi, key_lo, pt, ct)
    logic [127:0] kat_mem [0 : NUM_VECTORS*4 - 1];

    // key expansion: W[8] ... W[11] for vec0
    logic [31:0] kexp_mem [0:3];

    // scoreboard ctrs ===============================
    int total_pass;
    int total_fail;
    int stage_pass;
    int stage_fail;

    // Helpers =======================================

    // wait for a signal to go high, w/ timeout
    task automatic wait_for(
        input string   signal_name,
        ref   logic    signal,
        input int      max_cycles
    );
        int cyc;
        cyc = 0;
        while (!signal) begin
            @(posedge clk);
            cyc++;
        end
        if (!signal) begin
            $display("   [TIMEOUT] %s did not assert within %0d cycles", signal_name, max_cycles);
            total_fail++;
        end
    endtask

    // check a 32'b val
    task automatic check32(
        input string     label,
        input [31:0]     got,
        input [31:0]     expected
    );
        if (got === expected) begin
            $display("   [PASS] %s: got 0x%08h", label, got);
            stage_pass++;
            total_pass++;
        end else begin
            $display("   [FAIL] %s: expected 0x%08h  got 0x%08h", label, expected, got);
            stage_fail++;
            total_fail++;
        end
    endtask

    // check 128'b val
    task automatic check128(
        input string     label,
        input [127:0]    got,
        input [127:0]    expected
    );
        if (got === expected) begin
            $display("   [PASS] %s: got 0x%032h", label, got);
            stage_pass++;
            total_pass++;
        end else begin
            $display("   [FAIL] %s: expected 0x%032h  got 0x%032h", label, expected, got);
            stage_fail++;
            total_fail++;
        end
    endtask

    // load key, wait for ready
    task automatic load_key(input [255:0] key_in);
        @(posedge clk);
        key         <= key_in;
        key_valid   <= 1;
        @(posedge clk);
        key_valid   <= 0;
        key         <= '0;
        wait_for("ready", ready, TIMEOUT_CYCLES);
    endtask

    // encrypt block, wait for done
    task automatic encrypt_block (input [127:0] pt);
        @(posedge clk);
        plaintext     <= pt;
        encrypt_start <= 1;
        @(posedge clk);
        encrypt_start <= 0;
        plaintext     <= '0;
        wait_for("done", done, TIMEOUT_CYCLES);
    endtask

    // clear
    task automatic clear_done();
        @(posedge clk);
        clear <= 1;
        @(posedge clk);
        clear <= 0;
        wait_for("ready", ready, TIMEOUT_CYCLES);
    endtask


    // Main test sequence =================================
    initial begin
        // load golden vectors from hex files
        $readmemh("vectors/aes_kat.hex", kat_mem);
        $readmemh("vectors/aes_key_exp.hex", kexp_mem);

        // init signals
        rst_n         = 0;
        key           = '0;
        key_valid     = 0;
        plaintext     = '0;
        encrypt_start = 0;
        clear         = 0;
        total_pass    = 0;
        total_fail    = 0;

        // Reset
        repeat (4) @(posedge clk);
        rst_n = 1;
        repeat (2) @(posedge clk);

        // 2a: Key schedule verif ------------------------
        $display("");
        $display("================================");
        $display("   Stage 2a: Key Schedule Spot Check");
        $display("   Ref: NIST AES-256 key exansion");
        $display("   Golden: vectors/aes_key_exp.hex");
        $display("================================");
        
        stage_pass = 0;
        stage_fail = 0;

        // vector 0 key: {kat_mem[0], kat_mem[1]}
        load_key({kat_mem[0], kat_mem[1]});

        // Check W[8] ... W[11] against golden
        check32("W[8]",  dut.W[8],  kexp_mem[0]);
        check32("W[9]",  dut.W[9],  kexp_mem[1]);
        check32("W[10]", dut.W[10], kexp_mem[2]);
        check32("W[11]", dut.W[11], kexp_mem[3]);

        $display("--------------------------------");
        $display("  Results: %0d PASS  %0d FAIL  (of 4)", stage_pass, stage_fail);
        $display("================================");

        // 2b: Full KAT -------------------------------
        $display("");
        $display("================================");
        $display("   Stage 2b: Full AES-256 KAT");
        $display("   Vectors: %0d (from vectors/aes_kat.hex)", NUM_VECTORS);
        $display("================================");

        stage_pass = 0;
        stage_fail = 0;

        for (int v = 0; v < NUM_VECTORS; v++) begin
            automatic int base = v*4; // 4 lines/vec in kat_mem
            automatic logic [255:0] key_v = {kat_mem[base], kat_mem[base+1]};
            automatic logic [127:0] pt_v  = kat_mem[base+2];
            automatic logic [127:0] ct_v  = kat_mem[base+3];

            $display("");
            $display("-- Vector %0d --", v);
            $display("   Key: 0x%064h", key_v);
            $display("   PT:  0x%032h", pt_v);

            // Load key (1st vec loaded, but reload for cleas state)
            if (v > 0) begin
                // need to get back to a state where key_valid accepted
                // if in READY, key_valid tx to KEY_EXPAND
                // if in DONE after encrypt, clear first
            end

            // reset DUT between vectors for clean state
            rst_n = 0;
            repeat (2) @(posedge clk);
            rst_n = 1;
            repeat (2) @(posedge clk);

            // load key
            load_key(key_v);

            // encrypt
            encrypt_block(pt_v);

            // check
            check128($sformatf("Vector %0d ciphertext", v), ciphertext, ct_v);

            // clear 
            clear_done();
        end

        $display("");
        $display("--------------------------------");
        $display("   Stage 2b Results: %0d PASS  %0d FAIL  (of %0d)", stage_pass, stage_fail, NUM_VECTORS);
        $display("================================");

        if (stage_fail != 0) 
            $fatal(1, "Stage 2b FAILED - KAT mismatch.");  // nonzero exit - make detects failure

        // Final Summary
        $display("");
        $display("================================");
        $display("   AES Core Test Summary");
        $display("   Final Summary: %0d PASS  %0d FAIL", total_pass, total_fail);
        $display("================================");

        if (total_fail == 0) begin
            $display("   All tests PASSED!");
            $display("   Proceed to HW verification");
        end else begin
            $display("  VERIFICATION FAILED");
        end
        $display("================================");
        $display("");

        $finish;

    end


endmodule